在函数式编程当中有一个很重要的概念就是函数组合， 实际上就是把处理数据的函数像管道一样连接起来， 然后让数据穿过管道得到最终的结果。 例如：

```js
const add1 = (x) => x + 1;
const mul3 = (x) => x * 3;
const div2 = (x) => x / 2;
div2(mul3(add1(0))); // 3
```

而这样的写法可读性明显太差了，我们可以构建一个compose函数，它接受任意多个函数作为参数（这些函数都只接受一个参数），然后compose返回的也是一个函数，达到以下的效果：

```js
const operate = compose(div2, mul3, add1)
operate(0) // 相当于div2(mul3(add1(0))) 
operate(2) // 相当于div2(mul3(add1(2)))
```

简而言之：compose可以把类似于f(g(h(x)))这种写法简化成compose(f, g, h)(x)。

实现compose:

compose函数存储的是最后需要执行的函数及其顺序（最后传递的函数优先执行）
  + 执行compose只是把最后要执行的函数及顺序事先存储起来，函数还没有执行「柯理化思想」
  + 返回一个operate处理函数，执行operate，并且传递初始值，才按照之前存储的函数及顺序依次执行函数

```js
function compose(...funcs) {
    return function operate(x) {
        if (funcs.length === 0) return x;
        if (funcs.length === 1) return typeof funcs[0] === "function" ? funcs[0](x) : x;
        return funcs.reduceRight(function (result, item) {
            if (typeof item !== "function") return result;
            return item(result);
        }, x);
    };
}

const add1 = x => x + 1;
const mul3 = x => x * 3;
const div2 = x => x / 2;

var operate = compose(div2, mul3, add1);
var result = operate(0);
console.log(result);
```

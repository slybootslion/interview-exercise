---
title: "18道浏览器面试题"
date: 2021-02-20 10:43:38
tags:
  - 面试
  - 浏览器
---

<!--banner-pic|sticker|content-img|content-img-half-->
<img class="banner-pic" src="http://oss.slybootslion.com/blog/v2-8f6a0d81756ed17a257d7f292a8eb0b4_r.jpg?x-oss-process=image/auto-orient,1/quality,q_80/watermark,text_c2x5Ym9vdHNsaW9u,color_ffffff,size_40,shadow_70,t_74,x_10,y_10"/>


## 1\. 常见的浏览器内核有哪些\?

| 浏览器/RunTime | 内核（渲染引擎） | JavaScript 引擎                                                                 |
| -------------- | ---------------- | ------------------------------------------------------------------------------- |
| Chrome         | webkit->blink    | V8                                                                              |
| FireFox        | Gecko            | SpiderMonkey                                                                    |
| Safari         | Webkit           | JavaScriptCore                                                                  |
| Edge           | EdgeHTML         | Chakra\(for JavaScript\)                                                        |
| IE             | Trident          | JScript（IE3.0-IE8.0）                                                          |
| Opera          | Presto->blink    | Linear A（4.0-6.1）/ Linear B（7.0-9.2）/ Futhark（9.5-10.2）/ Carakan（10.5-） |
| Node.js        | \-               | V8                                                                              |

## 2\. 浏览器的主要组成部分是什么？

1.  **「用户界面」** - 包括地址栏、前进/后退按钮、书签菜单等。
2.  **「浏览器引擎」** - 在用户界面和呈现引擎之间传送指令。
3.  **「呈现引擎」** - 负责显示请求的内容。如果请求的内容是 HTML，它就负责解析 HTML 和 CSS 内容，并将解析后的内容显示在屏幕上。
4.  **「网络」** - 用于网络调用，比如 HTTP 请求。
5.  **「用户界面后端」** -用于绘制基本的窗口小部件，比如组合框和窗口。
6.  **「JavaScript解释器」**\- 用于解析和执行 JavaScript 代码。
7.  **「数据存储」** - 这是持久层。浏览器需要在硬盘上保存各种数据，例如 Cookie。新的 HTML 规范 \(HTML5\) 定义了“网络数据库”，这是一个完整（但是轻便）的浏览器内数据库。


## 3\. 为什么JavaScript是单线程的，与异步冲突吗（重点）

补充：JS中其实是没有线程概念的，所谓的单线程也只是相对于多线程而言。JS的设计初衷就没有考虑这些，针对JS这种不具备并行任务处理的特性，我们称之为“单线程”。

JS的单线程是指一个浏览器进程中只有一个JS的执行线程，同一时刻内只会有一段代码在执行。

举个通俗例子，假设JS支持多线程操作的话，JS可以操作DOM，那么一个线程在删除DOM，另外一个线程就在获取DOM数据，这样子明显不合理，这算是证明之一。

来看段代码👇

```js
function foo() {
 console.log("first");
 setTimeout((function(){
  console.log( 'second' );
 }),5);
}
for (var i = 0; i < 1000000; i++) {
  foo();
}
```

打印结果就是首先是很多个first,然后再是second。

异步机制是浏览器的两个或以上常驻线程共同完成的，举个例子，比如异步请求由两个常驻线程，JS执行线程和事件触发线程共同完成的。

- JS执行线程发起异步请求（浏览器会开启一个HTTP请求线程来执行请求，这时JS的任务完成，继续执行线程队列中剩下任务）
- 然后在未来的某一时刻事件触发线程监视到之前的发起的HTTP请求已完成，它就会把完成事件插入到JS执行队列的尾部等待JS处理

再比如定时器触发\(settimeout和setinterval\) 是由**「浏览器的定时器线程」**执行的定时计数，然后在定时时间把定时处理函数的执行请求插入到JS执行队列的尾端（所以用这两个函数的时候，实际的执行时间是大于或等于指定时间的，不保证能准确定时的）。

所以这么说，JS单线程与异步更多是浏览器行为，之间不冲突。

## 4\. CSS加载会造成阻塞吗（重点）

先给出结论
- `CSS`不会阻塞`DOM`解析，但会阻塞`DOM`渲染。
- `CSS`会阻塞JS执行，并不会阻塞JS文件下载

先讲一讲CSSOM作用
- 第一个是提供给 JavaScript 操作样式表的能力
- 第二个是为布局树的合成提供基础的样式信息
- 这个 CSSOM 体现在 DOM 中就是document.styleSheets。

由之前讲过的浏览器渲染流程我们可以看出：
DOM 和 CSSOM通常是并行构建的，所以**「CSS 加载不会阻塞 DOM 的解析」**。
然而由于Render Tree 是依赖DOM Tree和 CSSOM Tree的，所以它必须等到两者都加载完毕后，完成相应的构建，才开始渲染，因此，**「CSS加载会阻塞DOM渲染」**。

由于 JavaScript 是可操纵 DOM 和 css 样式 的,如果在修改这些元素属性同时渲染界面（即 JavaScript 线程和 UI 线程同时运行）,那么渲染线程前后获得的元素数据就可能不一致了。
因此为了防止渲染出现不可预期的结果,浏览器设置 **「GUI 渲染线程与 JavaScript 引擎为互斥」**的关系。

有个需要注意的点就是：
**「有时候JS需要等到CSS的下载，这是为什么呢？」**
仔细思考一下，其实这样做是有道理的，如果脚本的内容是获取元素的样式，宽高等`CSS`控制的属性，浏览器是需要计算的，也就是依赖于`CSS`。浏览器也无法感知脚本内容到底是什么，为避免样式获取，因而只好等前面所有的样式下载完后，再执行`JS`。
JS文件下载和CSS文件下载是并行的，有时候CSS文件很大，所以JS需要等待。
因此,样式表会在后面的 js 执行前先加载执行完毕,所以**「css 会阻塞后面 js 的执行」**。

## 5\. 为什么JS会阻塞页面加载（重点）

先给出结论👇
**「JS阻塞DOM解析」**，也就会阻塞页面

这也是为什么说JS文件放在最下面的原因，那为什么会阻塞DOM解析呢

你可以这样子理解：
> 由于 JavaScript 是可操纵 DOM 的,如果在修改这些元素属性同时渲染界面（即 JavaScript 线程和 UI 线程同时运行）,那么渲染线程前后获得的元素数据就可能不一致了。
> 因此为了防止渲染出现不可预期的结果,浏览器设置 **「GUI 渲染线程与 JavaScript 引擎为互斥」**的关系。
> 当 JavaScript 引擎执行时 GUI 线程会被挂起,GUI 更新会被保存在一个队列中等到引擎线程空闲时立即被执行。
> 当浏览器在执行 JavaScript 程序的时候,GUI 渲染线程会被保存在一个队列中,直到 JS 程序执行完成,才会接着执行。
> 因此如果 JS 执行的时间过长,这样就会造成页面的渲染不连贯,导致页面渲染加载阻塞的感觉。

另外，如果 JavaScript 文件中没有操作 DOM 相关代码，就可以将该 JavaScript 脚本设置为异步加载，通过 async 或 defer 来标记代码

## 6\. defer 和 async 的区别 \?

- 两者都是异步去加载外部JS文件，不会阻塞DOM解析
- Async是在外部JS加载完成后，浏览器空闲时，Load事件触发前执行，标记为async的脚本并不保证按照指定他们的先后顺序执行，该属性对于内联脚本无作用 \(即没有**「src」**属性的脚本）。
- defer是在JS加载完成后，整个文档解析完成后，触发 `DOMContentLoaded` 事件前执行，如果缺少 `src` 属性（即内嵌脚本），该属性不应被使用，因为这种情况下它不起作用

## 7\. DOMContentLoaded 与 load 的区别 \?

- DOMContentLoaded事件触发时：仅当DOM解析完成后，不包括样式表，图片等资源。
- onload 事件触发时,页面上所有的 DOM,样式表,脚本,图片等资源已经加载完毕。

那么也就是先DOMContentLoaded \-> load
在Jquery中，使用(document).read(callback)监听的就是DOMContentLoaded事件，\(document\).load\(callback\)监听的就是load事件。

那我们可以聊一聊它们与async和defer区别

> 带async的脚本一定会在load事件之前执行，可能会在DOMContentLoaded之前或之后执行。
- 情况1： HTML 还没有被解析完的时候，async脚本已经加载完了，那么 HTML 停止解析，去执行脚本，脚本执行完毕后触发DOMContentLoaded事件
- 情况2： HTML 解析完了之后，async脚本才加载完，然后再执行脚本，那么在HTML解析完毕、async脚本还没加载完的时候就触发DOMContentLoaded事件

> 如果 script 标签中包含 defer，那么这一块脚本将不会影响 HTML 文档的解析，而是等到HTML 解析完成后才会执行。而 DOMContentLoaded 只有在 defer 脚本执行结束后才会被触发。
- 情况1：HTML还没解析完成时，defer脚本已经加载完毕，那么defer脚本将等待HTML解析完成后再执行。defer脚本执行完毕后触发DOMContentLoaded事件
- 情况2：HTML解析完成时，defer脚本还没加载完毕，那么defer脚本继续加载，加载完成后直接执行，执行完毕后触发DOMContentLoaded事件

## 8\. 为什么CSS动画比JavaScript高效

我觉得这个题目说法上可能就是行不通，不能这么说，如果了解的话，都知道will-change只是一个优化的手段，使用JS改变transform也可以享受这个属性带来的变化，所以这个说法上有点不妥。

所以围绕这个问题展开话，更应该说建议推荐使用CSS动画，至于为什么呢，涉及的知识点大概就是重排重绘，合成，这方面的点，我在浏览器渲染流程中也提及了。

尽可能的避免重排和重绘，具体是哪些操作呢，如果非要去操作JS实现动画的话，有哪些优化的手段呢？

比如👇
- 使用`createDocumentFragment`进行批量的 DOM 操作
- 对于 resize、scroll 等进行防抖/节流处理。
- rAF优化等等

## 9\. 能不能实现事件防抖和节流（重点）

### 函数节流\(throttle\)

> 节流的意思是让函数有节制地执行，而不是毫无节制的触发一次就执行一次。什么叫有节制呢？就是在一段时间内，只执行一次。
> 
> 规定在一个单位时间内，只能触发一次函数。如果这个单位时间内触发多次函数，只有一次生效。

抓取一个关键的点：就是执行的时机。要做到控制执行的时机，我们可以通过**「一个开关」**，与定时器setTimeout结合完成。

```js
function throttle(fn, delay) {
 let flag = true,
 timer = null;
 return function (...args) {
  let context = this;
  if (!flag) return;
  flag = false;
  clearTimeout(timer)
  timer = setTimeout(() => {
    fn.apply(context, args);
    flag = true;
  }, delay);
 }
}
```

### 函数防抖\(debounce\)

> 在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时。

核心思想：每次事件触发都会删除原有定时器，建立新的定时器。通俗意思就是反复触发函数，只认最后一次，从最后一次开始计时。

代码：
```js
function debounce(fn, delay) {
 let timer = null
 return function (...args) {
  let context = this
  if(timer)   clearTimeout(timer)
  timer = setTimeout(function() {
    fn.apply(context, args)
  },delay)
 }
}
```

### 如何使用 debounce 和 throttle 以及常见的坑

自己造一个 debounce / throttle 的轮子看起来多么诱人，或者随便找个博文复制过来。**「我是建议直接使用 underscore 或 Lodash」** 。如果仅需要 `_.debounce` 和 `_.throttle` 方法，可以使用 Lodash 的自定义构建工具，生成一个 2KB 的压缩库。使用以下的简单命令即可：

```js
npm i -g lodash-cli
npm i -g lodash-clilodash-cli include=debounce,throttle
```

其实，lodash是可以按需加载的。

常见的坑是，不止一次地调用 `_.debounce` 方法：
```js
// 错误
$(window).on('scroll', function() {
 _.debounce(doSomething, 300); 
});
// 正确
$(window).on('scroll', _.debounce(doSomething, 200));
```

debounce 方法保存到一个变量以后，就可以用它的私有方法 `debounced_version.cancel()`，lodash 和 underscore.js 都有效。
```js
let debounced_version = _.debounce(doSomething, 200)
$(window).on('scroll', debounced_version) // 如果需要的话debounced_version.cancel();
```

### 适合应用场景

防抖
- search搜索，用户不断输入值时，用防抖来节约Ajax请求,也就是输入框事件。
- window触发resize时，不断的调整浏览器窗口大小会不断的触发这个事件，用防抖来让其只触发一次

节流
- 鼠标的点击事件，比如mousedown只触发一次
- 监听滚动事件，比如是否滑到底部自动加载更多，用throttle判断
- 比如游戏中发射子弹的频率\(1秒发射一颗\)

## 10\. 谈一谈你对requestAnimationFrame（rAF）理解

### **「高性能动画是什么，那它衡量的标准是什么呢？」**

动画帧率可以作为衡量标准，一般来说画面在 60fps 的帧率下效果比较好。

换算一下就是，每一帧要在 16.7ms \(16.7 = 1000/60\) 内完成渲染。

我们来看看MDN对它的解释吧👇

> window.requestAnimationFrame\(\) 方法告诉浏览器您希望执行动画并请求浏览器在下一次重绘之前调用指定的函数来更新动画。该方法使用一个回调函数作为参数，这个回调函数会在浏览器重绘之前调用。_\-- MDN_

当我们调用这个函数的时候，我们告诉它需要做两件事：

1.  我们需要新的一帧；
2.  当你渲染新的一帧时需要执行我传给你的回调函数

### rAF与 setTimeout 相比

rAF\(requestAnimationFrame\) 最大的优势是**「由系统来决定回调函数的执行时机」**。

具体一点讲就是，系统每次绘制之前会主动调用 rAF 中的回调函数，如果系统绘制率是 60Hz，那么回调函数就每16.7ms 被执行一次，如果绘制频率是75Hz，那么这个间隔时间就变成了 1000/75=13.3ms。

> 换句话说就是，rAF 的执行步伐跟着系统的绘制频率走。它能保证回调函数在屏幕每一次的绘制间隔中只被执行一次\(上一个知识点刚刚梳理完**「函数节流」**\)，这样就不会引起丢帧现象，也不会导致动画出现卡顿的问题。

另外它可以自动调节频率。如果callback工作太多无法在一帧内完成会自动降低为30fps。虽然降低了，但总比掉帧好。
与setTimeout动画对比的话，有以下几点优势
- 当页面隐藏或者最小化时，setTimeout仍然在后台执行动画，此时页面不可见或者是不可用状态，动画刷新没有意义，而言浪费CPU。
- rAF不一样，当页面处理未激活的状态时，该页面的屏幕绘制任务也会被系统暂停，因此跟着系统步伐走的rAF也会停止渲染，当页面被激活时，动画就从上次停留的地方继续执行，有效节省了 CPU 开销。

### 什么时候调用呢

规范中似乎是这么去定义的：

- 在重新渲染前调用。
- 很可能在宏任务之后不去调用

这样子分析的话，似乎很合理嘛，为什么要在重新渲染前去调用呢？因为rAF作为官方推荐的一种做流畅动画所应该使用的API，做动画不可避免的去操作DOM，而如果是在渲染后去修改DOM的话，那就只能等到下一轮渲染机会的时候才能去绘制出来了，这样子似乎不合理。

> `rAF`在浏览器决定渲染之前给你最后一个机会去改变 DOM 属性，然后很快在接下来的绘制中帮你呈现出来，所以这是做流畅动画的不二选择。

至于宏任务，微任务，这可以说起来就要展开篇幅了，暂时不在这里梳理了。

### rAF与节流相比
跟 `_.throttle(dosomething, 16)` 等价。它是高保真的，如果追求更好的精确度的话，可以用浏览器原生的 API 。
可以使用 rAF API 替换 throttle 方法，考虑一下优缺点：

优点

- 动画保持 60fps（每一帧 16 ms），浏览器内部决定渲染的最佳时机
- 简洁标准的 API，后期维护成本低

缺点

- 动画的开始/取消需要开发者自己控制，不像 ‘.debounce’ 或 ‘.throttle’由函数内部处理。
- 浏览器标签未激活时，一切都不会执行。
- 尽管所有的现代浏览器[都支持 rAF](http://caniuse.com/#feat=requestanimationframe) ，IE9，Opera Mini 和 老的 Android 还是[需要打补丁](http://www.paulirish.com/2011/requestanimationframe-for-smart-animating/)。
- Node.js 不支持，无法在服务器端用于文件系统事件。

根据经验，如果 JavaScript 方法需要绘制或者直接改变属性，我会选择 `requestAnimationFrame`，只要涉及到重新计算元素位置，就可以使用它。
涉及到 AJAX 请求，添加/移除 class （可以触发 CSS 动画），我会选择 `_.debounce` 或者 `_.throttle` ，可以设置更低的执行频率（例子中的200ms 换成16ms）。

## 12\. 说一说你对Cookie localStorage sessionStorage

### Cookie

得扯一下`HTTP是一个无状态的协议`，这里主要指的是HTTP1.x版本，简单的可以理解为即使同一个客户端连续两次发送请求给服务器，服务器也无法识别这个同一个客户端发的请求，导致的问题，比如现实生活中你加入一个商品到购物车，但是因为无法识别同一个客户端，你刷新页面的话就🤭

为了解决 HTTP 无状态导致的问题（HTTP1.x），后来出现了 Cookie。
> Cookie 的存在也不是为了解决通讯协议无状态的问题，只是为了解决客户端与服务端会话状态的问题，这个状态是指后端服务的状态而非通讯协议的状态。

Cookie存放在本地的好处就在于即使你关闭了浏览器，Cookie 依然可以生效。

#### Cookie设置

怎么去设置呢？简单来说就是👇
1.  客户端发送 HTTP 请求到服务器
2.  当服务器收到 HTTP 请求时，在响应头里面添加一个 Set-Cookie 字段
3.  浏览器收到响应后保存下 Cookie
4.  之后对该服务器每一次请求中都通过 Cookie 字段将 Cookie 信息发送给服务器。

#### Cookie指令
在下面这张图里我们可以看到 Cookies 相关的一些属性👇

![Cookie](https://user-gold-cdn.xitu.io/2020/7/23/1737930fe4756d53?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

这里主要说一些大家可能没有注意的点：
#### **「Name/Value」**
用 JavaScript 操作 Cookie 的时候注意对 Value 进行编码处理。

#### Expires/Max-Age
Expires 用于设置 Cookie 的过期时间。比如：
`Set-Cookie: id=aad3fWa; Expires=Wed, 21 May 2020 07:28:00 GMT;`

- 当 Expires 属性缺省时，表示是会话性 Cookie。
- 像上图 Expires 的值为 Session，表示的就是会话性 Cookie。
- 会话性 Cookie 的时候，值保存在客户端内存中，并在用户关闭浏览器时失效。
- 需要注意的是，有些浏览器提供了会话恢复功能，关闭浏览器，会话期Cookie会保留下来。
- 与会话性 Cookie 相对的是持久性 Cookie，持久性 Cookies 会保存在用户的硬盘中，直至过期或者清除 Cookie。

Max-Age 用于设置在 Cookie 失效之前需要经过的秒数。比如：
`Set-Cookie: id=a3fWa; Max-Age=604800;`

假如 Expires 和 Max-Age 都存在，Max-Age 优先级更高。

#### Domain
Domain 指定了 Cookie 可以送达的主机名。假如没有指定，那么默认值为当前文档访问地址中的主机部分（但是不包含子域名）。
在这里注意的是，不能跨域设置 Cookie

#### Path
Path 指定了一个 URL 路径，这个路径必须出现在要请求的资源的路径中才可以发送 Cookie 首部。比如设置 `Path=/docs`，`/docs/Web/` 下的资源会带 Cookie 首部，`/test` 则不会携带 Cookie 首部。
**「Domain 和 Path 标识共同定义了 Cookie 的作用域：即 Cookie 应该发送给哪些 URL。」**

#### Secure属性
标记为 Secure 的 Cookie 只应通过被HTTPS协议加密过的请求发送给服务端。使用 HTTPS 安全协议，可以保护 Cookie 在浏览器和 Web 服务器间的传输过程中不被窃取和篡改。

#### HTTPOnly
设置 HTTPOnly 属性可以防止客户端脚本通过 document.cookie 等方式访问 Cookie，有助于避免 XSS 攻击。

#### SameSite
SameSite 属性可以让 Cookie 在跨站请求时不会被发送，从而可以阻止跨站请求伪造攻击（CSRF）。
这个属性值修改有什么影响呢？
![Samesite](https://user-gold-cdn.xitu.io/2020/7/23/1737930fd2b1b628?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)
从上图可以看出，对大部分 web 应用而言，Post 表单，iframe，AJAX，Image 这四种情况从以前的跨站会发送三方 Cookie，变成了不发送。

#### Cookie 的作用
Cookie 主要用于以下三个方面：
1.  会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）
2.  个性化设置（如用户自定义设置、主题等）
3.  浏览器行为跟踪（如跟踪分析用户行为等）

#### Cookie 的缺点
从大小，安全，增加请求大小。

- 容量缺陷。Cookie 的体积上限只有`4KB`，只能用来存储少量的信息。
- 降低性能，Cookie紧跟着域名，不管域名下的某个地址是否需要这个Cookie，请求都会带上完整的Cookie，请求数量增加，会造成巨大的浪费。
- 安全缺陷，Cookie是以纯文本的形式在浏览器和服务器中传递，很容易被非法用户获取，当HTTPOnly为false时，Cookie信息还可以直接通过JS脚本读取。

### localStorage 和 sessionStorage
在 web 本地存储场景上，cookie 的使用受到种种限制，最关键的就是存储容量太小和数据无法持久化存储。
在 HTML 5 的标准下，出现了 localStorage 和 sessionStorage 供我们使用。

#### 异同点

| 分类           | 生命周期                                                                   | 存储容量                                   | 存储位置                                   |
| -------------- | -------------------------------------------------------------------------- | ------------------------------------------ | ------------------------------------------ |
| cookie         | 默认保存在内存中，随浏览器关闭失效（如果设置过期时间，在到过期时间后失效） | 4KB                                        | 保存在客户端，每次请求时都会带上           |
| localStorage   | 理论上永久有效的，除非主动清除。                                           | 4.98MB（不同浏览器情况不同，safari 2.49M） | 保存在客户端，不与服务端交互。节省网络流量 |
| sessionStorage | 仅在当前网页会话下有效，关闭页面或浏览器后会被清除。                       | 4.98MB（部分浏览器没有限制）               | 同上                                       |

#### 操作方式

接下来我们来具体看看如何来操作`localStorage`和`sessionStorage`

```js
let obj = { name: "TianTianUp", age: 18 };
localStorage.setItem("name", "TianTianUp"); 
localStorage.setItem("info", JSON.stringify(obj))
```

接着进入相同的域名时就能拿到相应的值👇

```js
let name = localStorage.getItem("name");
let info = JSON.parse(localStorage.getItem("info")); 
```

从这里可以看出，`localStorage`其实存储的都是字符串，如果是存储对象需要调用`JSON`的`stringify`方法，并且用`JSON.parse`来解析成对象。

#### 应用场景

- localStorage 适合持久化缓存数据，比如页面的默认偏好配置，如官网的`logo`，存储`Base64`格式的图片资源等；
- sessionStorage 适合一次性临时数据保存，存储本次浏览信息记录，这样子页面关闭的话，就不需要这些记录了，还有对表单信息进行维护，这样子页面刷新的话，也不会让表单信息丢失。

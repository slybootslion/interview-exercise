---
title: "金三银四突击队：第三天附加题"
date: 2021-02-24 18:46:18
tags:
  - 面试
  - 金三银四
---

<!--banner-pic|sticker|content-img|content-img-half-->

### 第一题
> 说下vue生命周期钩子函数?

这种题，问了就是白给。

- beforeCreate 在实例初始化之后，数据观测（data observer）和 event/watcher 事件配置之前被调用。
- created 实例已经创建完成之后被调用。在这一步，实例已完成以下的配置：数据观测（data observer），属性和方法的运算，watch/event事件回调。这里没有$el。实例已经创建完成，因为它时最早触发的原因可以进行一些数据资源的请求。服务端渲染只支持created方法。
- beforeMount 在挂载开始之前被调用：相关的render函数首次被调用。
- mounted el被新创建的vm.$el替换，并挂载到实例上去之后调用该钩子。实例已经挂载完成，可以进行一些DOM操作。服务器端渲染不支持。
- beforeUpdate 数据更新时调用，发生在虚拟DOM重新渲染和打补丁之前。可以在这个钩子函数中进一步地更改状态，这不会触发附加的重渲染过程。
- updated 由于数据更改导致的虚拟DOM重新渲染调用该钩子。可以执行依赖于DOM的操作，然而在大多数情况下，应该避免在此期间更改状态，因为这可能导致更新无限循环，服务器端渲染期间不被调用。
- beforeDestroy 实例销毁之前调用，在这一步实例仍然完全可用。
- destroyed 实例销毁后调用。调用后，Vue实例指示的所有东西都会解绑，所有的事件监听器会被移除，所有的子实例也会被销毁。可以执行一些优化操作，清空定时器，接触绑定事件。在服务器端渲染期间该钩子函数不可用。

### 第二题
> vue中computed和watch区别?

太基础，问了就是白给

- watch观察者作用，监视一个属性，当属性变化之后，做出一系列的操作。监听的属性发生变化后都会执行，可以做一些异步操作。
- cmoputed是计算属性，依赖其它属性，当依赖的属性发生变化时，返回重新计算后的值，返回的值有缓存，computed不支持异步操作。computed内部实现就是一个加了缓存的watcher。

运用场景：
- 当我们需要返回一个依赖数据计算后的结果时，使用computed（类似一对一，或多对一的关系），同时可以利用computed的缓存特性避免每次获取值的时候重复计算。
- 当我们需要观察的数据发生变化时做出一系列操作（类似一对多的关系），应该使用watch。

公布的答案：

### 1.

